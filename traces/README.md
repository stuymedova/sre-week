# traces

В этой задаче вам нужно написать утилиту для анализа распределённых трейсов. Каждый трейс представляет собой набор спанов, которые собираются с хостов по-отдельности. Утилита должна обрабатывать неупорядоченные спаны и находить:

1. Интервалы времени, когда общая нагрузка на систему была 80% и выше
2. Интервалы времени, когда какой-то один хост был загружен на 90% и выше

Для каждого найденного интервала утилита должна определить, от какого запроса нагрузка была больше всего (на всю систему или на отдельный хост соответственно)

Для простоты, в наших трейсах используется упрощённый формат: идентификаторы спанов - целые положительные числа, время считается в секундах, а загрузка системы представляется как целое число процентов среднего потребления CPU спаном (максимальное потребление CPU одним хостом - 100). Считаем, что нагрузка CPU одним спаном - равномерная.

Во входных данных спан представляется как

```
<имя хоста> <идентификатор спана> <идентификатор родительского спана> <время начала спана> <время завершения спана> <нагрузка CPU>
```

Если родительского спана нет, то спан является корневым и в качестве идентификатора родителя указывается `-1`. Мы считаем что корневые спаны тождествены запросам и используем идентификатор корневого спана в качестве идентификатора запросоа

Рассмотрим пример входных данных:

```
host1 1 -1 0 10 40
host1 2 1  3 6  40
```

В этом примере запрос приходит на хост `host1` и выполняется с 0 по 10 секунду (включительно). В процессе работы запрос порождает подзапрос на тот же хост, который выполняется с 3 по 6 секунду (также включительно). Средняя нагрузка на CPU как запросом так и подзапросом - 40%. Тем самым с 3 по 6 секунду потребление будет 80%, что попадает под условие перегрузки системы.

Выходные данные ожидаются в формате:
```
<начало интервала> <конец интервала> <загрузка CPU> <запрос с наибольшей нагрузкой> <нагрузка от этого запроса>
```
**Если на каком-то интервале запросов с наибольшей нагрузкой несколько, нужно вывести наименьший идентификатор**

Для примера выше получается:

```
3 6 80 1 80
```

В интервалах для хостов формат вывода аналогичный, только вначале добавляется имя хоста:
```
<имя хоста> <начало интервала> <конец интервала> <загрузка CPU> <запрос с наибольшей нагрузкой> <нагрузка от этого запроса>
```

**Интервалы в выходном файле должны следовать в порядке:**
* Сперва глобальные интервалы, отсортированные по времени.
* Затем интервалы для каждого хоста в алфовитном порядке, также отсортированные по времени.
* Соседние интервалы с одинаковой нагрузкой (общей и по наиболее нагружающему запросу) должны быть объединены в один.

Например, для входа
```
host2 1 -1 0 10 90
host1 2 1  3 6  90
```

Должен получиться ответ
```
3 6 180 1 180
host1 3 6 90 1 90
host2 0 10 90 1 90
```

Ваша программа должна читать файл, имя которого передано в виде аргумента командной строки, и выводить ответ в стандартный вывод (`stdout`). То есть должно получиться что-то вроде:

```
$ ./traces input.txt
3 6 80 1 80
host1 3 6 90 1 90
host2 0 10 90 1 90
```
